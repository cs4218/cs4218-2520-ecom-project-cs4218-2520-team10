// AI Policy : the following file is generated by AI
// Test cases written by: KIM SHI TONG A0265858J

/**
 * Unit Tests for Login Component
 *
 * Tests user login form including:
 * - UI rendering and form structure
 * - Form input handling and state management
 * - Form submission with success/error paths
 * - API integration (axios.post)
 * - Side effects (toast notifications, localStorage, setAuth, navigation)
 * - Forgot Password button navigation
 * - Security invariants (password handling)
 * - Boundary value edge cases
 *
 * Coverage Target: 100% (lines + branches)
 * Test Strategy: Output-based, State-based, Communication-based testing
 *
 * Test Doubles Used:
 * - axios.post/get:     STUB (returns controlled test data) + MOCK (verify calls)
 * - toast:              MOCK (verify success/error calls with messages)
 * - useNavigate:        MOCK (verify navigation to / or forgot-password)
 * - useAuth:            STUB (return default state) + MOCK (verify setAuth calls)
 * - useCart/Search:     STUB (return default state)
 * - localStorage:       Mock (test double for browser API)
 *
 * Testing Techniques Applied:
 * - Equivalence Partitioning (EP): Valid/invalid input groups
 * - Boundary Value Analysis (BVA): Empty, min, max, special chars
 * - Decision Table Testing: Multi-path form submission logic
 * - State Transition Testing: Form input → submission → success/error states
 * - Communication-Based Testing: Verify side effects (toast, navigate, axios, setAuth)
 *
 * Scenario Coverage:
 * #  | Category                | Technique | Scenario
 * 1  | UI Rendering            | —         | Form title, fields, buttons render
 * 2  | Form Input              | —         | Email and password fields update state correctly
 * 3  | Happy Path              | —         | Successful login → toast.success
 * 4  | API Error               | EP+DT     | success=false → error toast, no success toast
 * 5  | Exception               | —         | axios throws → error toast, no success toast
 * 6  | Forgot Password         | —         | Button click → navigate to /forgot-password
 * 7  | Boundary Values         | BVA       | Min/max/special char inputs
 * 8  | Equivalence Partitions  | EP        | Various email format variants
 *
 * ═══════════════════════════════════════════════════════════════════════════
 * NOTE: WHY NO CLIENT-SIDE VALIDATION TESTS?
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * This test suite does NOT include tests for:
 *   ❌ Invalid email format (e.g., "notanemail", "test@")
 *   ❌ Empty/missing required fields
 *   ❌ XSS/SQL injection attempts
 *
 * REASON: The Login component contains ZERO client-side validation logic.
 *
 * Validation Strategy:
 *   1. HTML5 Browser Validation (NOT testable in unit tests):
 *      - <input type="email" required />  ← Browser prevents invalid email
 *      - Both inputs have 'required' attribute
 *
 *   2. Backend API Validation (tested in backend unit tests):
 *      - Email format validation
 *      - Required field checks
 *      - SQL injection prevention
 *      - XSS sanitization
 *      - See: /controllers/authController.test.js
 *
 * Component Behavior:
 *   The Login component is a "thin client" that:
 *   - Collects user input into React state
 *   - Sends input values as-is to /api/v1/auth/login
 *   - Displays success/error messages from API response
 *   - Does NOT validate, sanitize, or transform input
 *
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * @see Login.js
 */

import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react';
import axios from 'axios';
import { MemoryRouter, Routes, Route } from 'react-router-dom';
import '@testing-library/jest-dom/extend-expect';
import toast from 'react-hot-toast';
import Login from './Login';

// Mocking dependencies
jest.mock('axios');
jest.mock('react-hot-toast');

// Mock useNavigate at module level
const mockNavigate = jest.fn();
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => mockNavigate,
}));

jest.mock('../../context/auth', () => ({
    useAuth: jest.fn(() => [null, jest.fn()]) // Mock useAuth hook to return null state and a mock function for setAuth
  }));

  jest.mock('../../context/cart', () => ({
    useCart: jest.fn(() => [null, jest.fn()]) // Mock useCart hook to return null state and a mock function
  }));

jest.mock('../../context/search', () => ({
    useSearch: jest.fn(() => [{ keyword: '' }, jest.fn()]) // Mock useSearch hook to return null state and a mock function
  }));

  Object.defineProperty(window, 'localStorage', {
    value: {
      setItem: jest.fn(),
      getItem: jest.fn(),
      removeItem: jest.fn(),
    },
    writable: true,
  });

window.matchMedia = window.matchMedia || function() {
    return {
      matches: false,
      addListener: function() {},
      removeListener: function() {}
    };
  };

// ═══════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Helper function to fill the login form with test data
 * Reduces code duplication across tests
 *
 * @param {Object} getByPlaceholderText - React Testing Library query function
 * @param {Object} overrides - Optional field overrides for the default form data
 * @returns {Object} The form data used to fill the form
 */
const fillLoginForm = (getByPlaceholderText, overrides = {}) => {
  const defaults = {
    email: 'test@example.com',
    password: 'password123'
  };
  const formData = { ...defaults, ...overrides };

  fireEvent.change(getByPlaceholderText('Enter Your Email'),
    { target: { value: formData.email } });
  fireEvent.change(getByPlaceholderText('Enter Your Password'),
    { target: { value: formData.password } });

  return formData;
};

/**
 * Helper function to render Login component with routing
 * Reduces boilerplate setup code
 *
 * @param {Object} options - Optional configuration for routing
 * @param {string} options.initialRoute - Initial route path (default: '/login')
 * @param {Object} options.locationState - State to pass to location (default: null)
 * @returns {Object} React Testing Library render result
 */
const renderLoginComponent = (options = {}) => {
  const { initialRoute = '/login', locationState = null } = options;
  return render(
    <MemoryRouter initialEntries={[{ pathname: initialRoute, state: locationState }]}>
      <Routes>
        <Route path="/login" element={<Login />} />
      </Routes>
    </MemoryRouter>
  );
};

// ═══════════════════════════════════════════════════════════════════════════
// TEST SUITE
// ═══════════════════════════════════════════════════════════════════════════

describe('Login Component', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        mockNavigate.mockClear();
        // Fix: Mock axios.get for useCategory hook - KIM SHI TONG A0265858J
        axios.get.mockResolvedValue({
            data: { success: true, category: [] }
        });
    });

    // ───────────────────────────────────────────────────────────────────────
    // 1. RENDER - UI RENDERING TESTS
    // ───────────────────────────────────────────────────────────────────────
    describe('render', () => {
      describe('Happy Path', () => {
        it('should render form title correctly', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByText } = renderLoginComponent();

          // ── ACT ──────────────────────────────────────────
          // (no action needed - testing initial render)

          // ── ASSERT ───────────────────────────────────────
          expect(getByText('LOGIN FORM')).toBeInTheDocument();
        });

        it('should display email input with correct type and required attribute', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByPlaceholderText } = renderLoginComponent();

          // ── ACT ──────────────────────────────────────────
          // (no action needed - testing initial render)

          // ── ASSERT ───────────────────────────────────────
          const emailInput = getByPlaceholderText('Enter Your Email');
          expect(emailInput).toBeInTheDocument();
          expect(emailInput).toHaveAttribute('type', 'email');
          expect(emailInput).toHaveAttribute('required');
        });

        it('should display password input with correct type and required attribute', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByPlaceholderText } = renderLoginComponent();

          // ── ACT ──────────────────────────────────────────
          // (no action needed - testing initial render)

          // ── ASSERT ───────────────────────────────────────
          const passwordInput = getByPlaceholderText('Enter Your Password');
          expect(passwordInput).toBeInTheDocument();
          expect(passwordInput).toHaveAttribute('type', 'password');
          expect(passwordInput).toHaveAttribute('required');
        });

        it('should display LOGIN submit button', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByText } = renderLoginComponent();

          // ── ACT ──────────────────────────────────────────
          // (no action needed - testing initial render)

          // ── ASSERT ───────────────────────────────────────
          const loginButton = getByText('LOGIN');
          expect(loginButton).toBeInTheDocument();
          expect(loginButton).toHaveAttribute('type', 'submit');
        });

        it('should display Forgot Password button with type button', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByText } = renderLoginComponent();

          // ── ACT ──────────────────────────────────────────
          // (no action needed - testing initial render)

          // ── ASSERT ───────────────────────────────────────
          const forgotPasswordButton = getByText('Forgot Password');
          expect(forgotPasswordButton).toBeInTheDocument();
          expect(forgotPasswordButton).toHaveAttribute('type', 'button');
        });

        it('should initialize all inputs with empty values', () => {
          // ── ARRANGE ──────────────────────────────────────
          // BVA: Testing minimum/empty boundary for initial state
          const { getByPlaceholderText } = renderLoginComponent();

          // ── ACT ──────────────────────────────────────────
          // (no action needed - testing initial state)

          // ── ASSERT ───────────────────────────────────────
          expect(getByPlaceholderText('Enter Your Email').value).toBe('');
          expect(getByPlaceholderText('Enter Your Password').value).toBe('');
        });
      });
    }); // end render

    // ───────────────────────────────────────────────────────────────────────
    // 2. HANDLE INPUT CHANGE - FORM INPUT HANDLING TESTS
    // ───────────────────────────────────────────────────────────────────────
    describe('handleInputChange', () => {
      describe('Happy Path', () => {
        it('should update email field when user types', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByPlaceholderText } = renderLoginComponent();
          const emailInput = getByPlaceholderText('Enter Your Email');

          // ── ACT ──────────────────────────────────────────
          fireEvent.change(emailInput, { target: { value: 'test@example.com' } });

          // ── ASSERT ───────────────────────────────────────
          expect(emailInput.value).toBe('test@example.com');
        });

        it('should update password field when user types', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByPlaceholderText } = renderLoginComponent();
          const passwordInput = getByPlaceholderText('Enter Your Password');

          // ── ACT ──────────────────────────────────────────
          fireEvent.change(passwordInput, { target: { value: 'password123' } });

          // ── ASSERT ───────────────────────────────────────
          expect(passwordInput.value).toBe('password123');
        });

        it('should allow clearing and retyping field values', () => {
          // ── ARRANGE ──────────────────────────────────────
          // BVA: Testing state transition from filled → empty → filled
          const { getByPlaceholderText } = renderLoginComponent();
          const emailInput = getByPlaceholderText('Enter Your Email');

          // ── ACT ──────────────────────────────────────────
          fireEvent.change(emailInput, { target: { value: 'initial@test.com' } });
          fireEvent.change(emailInput, { target: { value: '' } });
          fireEvent.change(emailInput, { target: { value: 'new@test.com' } });

          // ── ASSERT ───────────────────────────────────────
          expect(emailInput.value).toBe('new@test.com');
        });
      });
    }); // end handleInputChange

    // ───────────────────────────────────────────────────────────────────────
    // 3. FORGOT PASSWORD BUTTON - UI NAVIGATION TESTS
    // ───────────────────────────────────────────────────────────────────────
    describe('Forgot Password Button', () => {
      describe('UI Navigation', () => {
        it('should navigate to /forgot-password when button clicked', () => {
          // ── ARRANGE ──────────────────────────────────────
          const { getByText } = renderLoginComponent();
          const forgotPasswordButton = getByText('Forgot Password');

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(forgotPasswordButton);

          // ── ASSERT ───────────────────────────────────────
          expect(mockNavigate).toHaveBeenCalledWith('/forgot-password');
        });
      });
    }); // end Forgot Password Button

    // ───────────────────────────────────────────────────────────────────────
    // 4. HANDLE SUBMIT - FORM SUBMISSION TESTS
    // ───────────────────────────────────────────────────────────────────────
    describe('handleSubmit', () => {
      describe('Happy Path', () => {
        it('should login the user successfully', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // EP: Valid partition - successful login
          const mockUser = { id: 1, name: 'John Doe', email: 'test@example.com' };
          const mockToken = 'mockToken';

          axios.post.mockResolvedValueOnce({
              data: {
                  success: true,
                  message: 'Login successful',
                  user: mockUser,
                  token: mockToken
              }
          });

          const mockSetAuth = jest.fn();
          const mockAuth = { user: null, token: '' };
          require('../../context/auth').useAuth.mockReturnValue([mockAuth, mockSetAuth]);

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
        });
      });

      describe('Side Effects', () => {
        let mockSetAuth;

        beforeEach(() => {
          const mockUser = { id: 1, name: 'John Doe', email: 'test@example.com' };
          mockSetAuth = jest.fn();
          axios.post.mockResolvedValue({
            data: { success: true, message: 'Login successful', user: mockUser, token: 'mockToken' }
          });
          require('../../context/auth').useAuth.mockReturnValue([{ user: null, token: '' }, mockSetAuth]);
        });

        it('should perform all success side effects when login succeeds', async () => {
          // ── ARRANGE ── (in beforeEach)

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));
          await waitFor(() => expect(axios.post).toHaveBeenCalled());

          // ── ASSERT ───────────────────────────────────────────
          expect(mockSetAuth).toHaveBeenCalled();
          expect(window.localStorage.setItem).toHaveBeenCalled();
          expect(mockNavigate).toHaveBeenCalled();
          expect(toast.success).toHaveBeenCalled();
        });

        it('should navigate to location.state path when provided', async () => {
          // ── ARRANGE ──────────────────────────────────────────
          // State Transition: redirect destination comes from location.state
          axios.post.mockResolvedValueOnce({ data: { success: true, user: {}, token: 'token' } });
          const { getByPlaceholderText, getByText } = renderLoginComponent({ locationState: '/dashboard' });
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(mockNavigate).toHaveBeenCalledWith('/dashboard');
        });

        it('should navigate to home when no location.state', async () => {
          // ── ARRANGE ──────────────────────────────────────────
          // State Transition: no redirect path → default to '/'
          axios.post.mockResolvedValueOnce({ data: { success: true, user: {}, token: 'token' } });
          const { getByPlaceholderText, getByText } = renderLoginComponent(); // locationState: null
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(mockNavigate).toHaveBeenCalledWith('/');
        });
      });

      describe('Error Handling', () => {
        it('should display error message when API returns success false', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // EP: Invalid partition - API rejects login
          // CRITICAL TEST: Covers untested path (res.data.success = false)
          axios.post.mockResolvedValueOnce({
            data: {
              success: false,
              message: 'Invalid email or password'
            }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.error).toHaveBeenCalled();
          expect(toast.success).not.toHaveBeenCalled();
        });

        it('should not trigger success side effects when API returns error', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // Decision Table: Verify early-exit on API error (no setAuth, localStorage, navigate)
          const mockSetAuth = jest.fn();
          const mockAuth = { user: null, token: '' };
          require('../../context/auth').useAuth.mockReturnValue([mockAuth, mockSetAuth]);

          axios.post.mockResolvedValueOnce({
            data: {
              success: false,
              message: 'Login failed'
            }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());

          // Verify early-exit: NO success side effects
          expect(toast.error).toHaveBeenCalled();
          expect(toast.success).not.toHaveBeenCalled();
        });

        it('should handle specific error messages from API', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // EP: Testing different error message variants
          axios.post.mockResolvedValueOnce({
            data: {
              success: false,
              message: 'Account is locked'
            }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.error).toHaveBeenCalled();
        });

        it('should display error message on failed login', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // Exception path - axios throws error
          axios.post.mockRejectedValueOnce({ message: 'Invalid credentials' });

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.error).toHaveBeenCalled();
        });

        it('should not trigger success side effects when exception occurs', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // Decision Table: Verify early-exit on exception (no setAuth, localStorage, navigate)
          const mockSetAuth = jest.fn();
          const mockAuth = { user: null, token: '' };
          require('../../context/auth').useAuth.mockReturnValue([mockAuth, mockSetAuth]);

          axios.post.mockRejectedValueOnce(new Error('Network error'));

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());

          // Verify early-exit: NO success side effects
          expect(toast.error).toHaveBeenCalled();
          expect(toast.success).not.toHaveBeenCalled();
        });

        it('should handle network timeout scenario', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // Exception path - specific error type (timeout)
          axios.post.mockRejectedValueOnce({ code: 'ECONNABORTED', message: 'timeout' });

          const { getByPlaceholderText, getByText } = renderLoginComponent();
          fillLoginForm(getByPlaceholderText);

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.error).toHaveBeenCalled();
        });
      });


      describe('Boundary Values', () => {
        it('should accept minimum valid input (1 character strings)', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // BVA: Minimum boundary values for string inputs
          axios.post.mockResolvedValueOnce({
            data: { success: true, user: {}, token: 'token' }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();

          fillLoginForm(getByPlaceholderText, {
            email: 'a@b.c',
            password: '1'
          });

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.success).toHaveBeenCalled();
        });

        it('should accept very long input values (200 characters)', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // BVA: Maximum boundary values (very long strings)
          const MAX_PASSWORD_LENGTH = 200; // BVA: upper boundary for password length
          axios.post.mockResolvedValueOnce({
            data: { success: true, user: {}, token: 'token' }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();

          const longPassword = 'A'.repeat(MAX_PASSWORD_LENGTH);
          fillLoginForm(getByPlaceholderText, {
            password: longPassword
          });

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.success).toHaveBeenCalled();
        });

        it('should handle special characters in input fields', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // BVA: Special character boundary cases
          axios.post.mockResolvedValueOnce({
            data: { success: true, user: {}, token: 'token' }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();

          const specialEmail = 'test+tag@example.co.uk';
          const specialPassword = 'P@$$w0rd!#%';

          fillLoginForm(getByPlaceholderText, {
            email: specialEmail,
            password: specialPassword
          });

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.success).toHaveBeenCalled();
        });
      });

      describe('Equivalence Partitions', () => {
        it('should accept standard email format', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // EP: Valid partition - standard email format
          axios.post.mockResolvedValueOnce({
            data: { success: true, user: {}, token: 'token' }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();

          fillLoginForm(getByPlaceholderText, {
            email: 'user@example.com'
          });

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.success).toHaveBeenCalled();
        });

        it('should accept email with subaddressing', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // EP: Valid partition - email with plus sign subaddressing
          axios.post.mockResolvedValueOnce({
            data: { success: true, user: {}, token: 'token' }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();

          fillLoginForm(getByPlaceholderText, {
            email: 'user+test@example.com'
          });

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.success).toHaveBeenCalled();
        });

        it('should accept email with subdomain', async () => {
          // ── ARRANGE ──────────────────────────────────────
          // EP: Valid partition - email with subdomain
          axios.post.mockResolvedValueOnce({
            data: { success: true, user: {}, token: 'token' }
          });

          const { getByPlaceholderText, getByText } = renderLoginComponent();

          fillLoginForm(getByPlaceholderText, {
            email: 'user@mail.example.com'
          });

          // ── ACT ──────────────────────────────────────────
          fireEvent.click(getByText('LOGIN'));

          // ── ASSERT ───────────────────────────────────────
          await waitFor(() => expect(axios.post).toHaveBeenCalled());
          expect(toast.success).toHaveBeenCalled();
        });
      });
    }); // end handleSubmit
});
