// AI Policy : the following file is generated by AI

/**
 * Unit Tests for Client-Side Auth Context (context/auth.js)
 *
 * Tests authentication context provider and custom hook including:
 * - Component rendering and context provision
 * - localStorage persistence (load on mount)
 * - axios authorization header synchronization
 * - State management and transitions
 * - useAuth hook functionality
 * - Error handling for invalid JSON and missing localStorage
 * - Security: no token exposure in error logs
 *
 * Coverage Target: 100% (lines + functions)
 * Test Strategy: Output-based + State-based + Communication-based testing
 *
 * Test Doubles Used:
 * - localStorage.getItem:  STUB (returns controlled test data: valid JSON, null, invalid JSON)
 *                          SPY (verify called on mount)
 * - localStorage.setItem:  Not used by auth.js (read-only)
 * - axios.defaults.headers: MOCK (verify Authorization header set correctly)
 * - console.log:           SPY (monitors error logging, verify no token exposure)
 * - React Context:         REAL (use actual React Context via React Testing Library)
 *
 * Testing Techniques Applied:
 * - Equivalence Partitioning (EP): Valid/invalid localStorage data partitions
 * - Boundary Value Analysis (BVA): Empty strings, null, undefined values
 * - State Transition Testing: Auth state changes, token updates
 * - Error Guessing: JSON.parse errors, localStorage access errors
 * - Decision Table Testing: Coverage of localStorage data conditions
 *
 * Scenario Plan:
 * AuthProvider Component:
 * #  | Category    | Technique | Scenario                        | Expected
 * 1  | Happy       | —         | no localStorage data            | default state + children rendered
 * 2  | Happy       | —         | valid localStorage user+token   | state loaded + children rendered
 * 3  | Happy       | —         | token present in state          | axios header = token
 * 4  | Partition   | EP        | localStorage = null             | default state
 * 5  | Partition   | EP        | localStorage = valid JSON       | parsed state
 * 6  | Boundary    | BVA       | empty string token              | auth.token = ""
 * 7  | Boundary    | BVA       | null user field                 | auth.user = null
 * 8  | Boundary    | BVA       | localStorage = ""               | default state
 * 9  | Error       | —         | invalid JSON                    | console.log + default state
 * 10 | Error       | —         | getItem throws                  | console.log + default state
 * 11 | State Trans | FSM       | setAuth updates state           | consumers see new state
 * 12 | State Trans | FSM       | token: empty → value            | axios header updated
 * 13 | State Trans | FSM       | token: value → empty            | axios header cleared
 * 14 | Side Effect | —         | mount with no data              | getItem called once
 * 15 | Side Effect | —         | data exists                     | state updated from storage
 * 16 | Side Effect | —         | localStorage null               | setAuth NOT called
 * 17 | Side Effect | —         | invalid JSON                    | console.log called
 * 18 | Security    | —         | error logged                    | no token in log message
 * 19 | Security    | —         | axios header                    | matches token exactly
 *
 * useAuth Hook:
 * 20 | Happy       | —         | used inside provider            | returns [auth, setAuth]
 * 21 | Happy       | —         | setAuth updates                 | new state returned
 * 22 | Error       | —         | used outside provider           | throws helpful error
 * 23 | Side Effect | —         | multiple components             | same state reference
 * 24 | Side Effect | —         | one component updates           | all consumers see update
 */

import React from "react";
import { render, screen, waitFor } from "@testing-library/react";
import { renderHook, act } from "@testing-library/react";
import { AuthProvider, useAuth } from "./auth";
import axios from "axios";

// ══════════════════════════════════════════════════════════════════════════════
// MOCK DECLARATIONS
// ══════════════════════════════════════════════════════════════════════════════

jest.mock("axios", () => ({
    defaults: {
        headers: {
            common: {}
        }
    }
}));

// ══════════════════════════════════════════════════════════════════════════════
// TEST SUITE: AuthContext
// ══════════════════════════════════════════════════════════════════════════════

describe("AuthContext", () => {
    describe("AuthProvider", () => {
        /**
         * Decision Table — AuthProvider localStorage loading flow:
         *         | Rule 1 | Rule 2 | Rule 3 | Rule 4 |
         * --------|--------|--------|--------|--------|
         * C1: localStorage has data? |   N    |   Y    |   Y    |   Y    |
         * C2: data is valid JSON?    |   -    |   Y    |   N    |   -    |
         * C3: getItem throws error?  |   N    |   N    |   N    |   Y    |
         * --------|--------|--------|--------|--------|
         * A1: use default state      |   X    |        |   X    |   X    |
         * A2: load from storage      |        |   X    |        |        |
         * A3: log error              |        |        |   X    |   X    |
         */

        let consoleLogSpy;
        let localStorageGetItemSpy;

        // ────────────────────────────────────────────────────────────────────────────
        // SETUP & TEARDOWN
        // ────────────────────────────────────────────────────────────────────────────

        beforeEach(() => {
            // Clear axios headers before each test
            axios.defaults.headers.common = {};

            // Spy on console.log for error logging verification
            consoleLogSpy = jest.spyOn(console, "log").mockImplementation(() => {});

            // Mock localStorage
            localStorageGetItemSpy = jest.spyOn(Storage.prototype, "getItem");
        });

        afterEach(() => {
            // Clear all mocks to ensure test isolation
            jest.clearAllMocks();
            consoleLogSpy.mockRestore();
            localStorageGetItemSpy.mockRestore();
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // HAPPY PATH TESTS (EP: Valid Partition)
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Happy Path", () => {
            it("should render children with default auth state when no localStorage data exists", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // EP: Valid partition - no data in localStorage (null)
                localStorageGetItemSpy.mockReturnValue(null);

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <div data-testid="test-child">Test Child</div>
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // Children should be rendered
                expect(screen.getByTestId("test-child")).toBeInTheDocument();
                expect(screen.getByText("Test Child")).toBeInTheDocument();
            });

            it("should render children and load auth from localStorage when valid data exists", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // EP: Valid partition - localStorage contains valid JSON with user and token
                const mockAuthData = {
                    user: {
                        _id: "user123",
                        name: "Test User",
                        email: "test@example.com",
                        role: 0
                    },
                    token: "mock.jwt.token.xyz"
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                // Create a component to access and display auth state
                const TestComponent = () => {
                    const [auth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user-name">{auth.user?.name || "No user"}</div>
                            <div data-testid="token">{auth.token || "No token"}</div>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // State should be loaded from localStorage asynchronously
                await waitFor(() => {
                    expect(screen.getByTestId("user-name")).toHaveTextContent("Test User");
                    expect(screen.getByTestId("token")).toHaveTextContent("mock.jwt.token.xyz");
                });
            });

            it("should set axios authorization header when auth state has token", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // EP: Valid partition - auth state contains token
                const mockAuthData = {
                    user: { _id: "user123", name: "Test User" },
                    token: "Bearer.test.token.123"
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return <div data-testid="token">{auth.token}</div>;
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // axios header should be set when component renders with token
                await waitFor(() => {
                    expect(axios.defaults.headers.common["Authorization"]).toBe("Bearer.test.token.123");
                });
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // EQUIVALENCE PARTITIONS
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Equivalence Partitions", () => {
            it("should use default state when localStorage returns null", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // EP: Null partition - no data stored
                localStorageGetItemSpy.mockReturnValue(null);

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user">{auth.user === null ? "null" : "not-null"}</div>
                            <div data-testid="token">{auth.token === "" ? "empty" : "not-empty"}</div>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(screen.getByTestId("user")).toHaveTextContent("null");
                    expect(screen.getByTestId("token")).toHaveTextContent("empty");
                });
            });

            it("should parse and set state correctly when localStorage returns valid JSON string", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // EP: Valid JSON partition - well-formed JSON with all required fields
                const mockAuthData = {
                    user: {
                        _id: "abc123",
                        name: "John Doe",
                        email: "john@example.com"
                    },
                    token: "valid.jwt.token"
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user-id">{auth.user?._id || "no-id"}</div>
                            <div data-testid="token">{auth.token || "no-token"}</div>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(screen.getByTestId("user-id")).toHaveTextContent("abc123");
                    expect(screen.getByTestId("token")).toHaveTextContent("valid.jwt.token");
                });
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // BOUNDARY VALUE ANALYSIS (BVA)
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Boundary Values", () => {
            it("should handle empty string token correctly", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // BVA: On-boundary value - empty string token (length = 0)
                const mockAuthData = {
                    user: { _id: "user123", name: "Test User" },
                    token: ""  // BVA: Boundary - empty string
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return <div data-testid="token">{auth.token === "" ? "empty-token" : auth.token}</div>;
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(screen.getByTestId("token")).toHaveTextContent("empty-token");
                });
            });

            it("should handle null user field correctly", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // BVA: Boundary value - null user (distinct from undefined and empty object)
                const mockAuthData = {
                    user: null,  // BVA: Explicit null value
                    token: "some.token"
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return <div data-testid="user">{auth.user === null ? "null-user" : "has-user"}</div>;
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(screen.getByTestId("user")).toHaveTextContent("null-user");
                });
            });

            it("should use default state when localStorage returns empty string", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // BVA: On-boundary value - empty string (falsy value, length = 0)
                localStorageGetItemSpy.mockReturnValue("");

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user">{auth.user === null ? "null" : "not-null"}</div>
                            <div data-testid="token">{auth.token === "" ? "empty" : "not-empty"}</div>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // Empty string is falsy, so if (data) check fails → default state used
                await waitFor(() => {
                    expect(screen.getByTestId("user")).toHaveTextContent("null");
                    expect(screen.getByTestId("token")).toHaveTextContent("empty");
                });
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // ERROR HANDLING
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Error Handling", () => {
            it("should handle invalid JSON gracefully and use default state", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Error Guessing: localStorage contains malformed JSON
                localStorageGetItemSpy.mockReturnValue("{invalid-json}");

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user">{auth.user === null ? "null" : "not-null"}</div>
                            <div data-testid="token">{auth.token === "" ? "empty" : "not-empty"}</div>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // Should use default state despite error
                await waitFor(() => {
                    expect(screen.getByTestId("user")).toHaveTextContent("null");
                    expect(screen.getByTestId("token")).toHaveTextContent("empty");
                });
            });

            it("should handle localStorage.getItem throwing error and use default state", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Error Guessing: localStorage access throws SecurityError (e.g., private browsing)
                const securityError = new Error("SecurityError: Access denied");
                localStorageGetItemSpy.mockImplementation(() => {
                    throw securityError;
                });

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user">{auth.user === null ? "null" : "not-null"}</div>
                            <div data-testid="rendered">rendered</div>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // Component should still render with default state
                await waitFor(() => {
                    expect(screen.getByTestId("rendered")).toBeInTheDocument();
                    expect(screen.getByTestId("user")).toHaveTextContent("null");
                });
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // STATE TRANSITIONS (FSM)
        // ══════════════════════════════════════════════════════════════════════════════

        describe("State Transitions", () => {
            it("should update context state when setAuth is called", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // State Transition: Default state → Authenticated state
                localStorageGetItemSpy.mockReturnValue(null);

                const TestComponent = () => {
                    const [auth, setAuth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user-name">{auth.user?.name || "no-user"}</div>
                            <button
                                onClick={() => setAuth({
                                    user: { name: "Updated User" },
                                    token: "new.token"
                                })}
                            >
                                Update Auth
                            </button>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                const updateButton = screen.getByText("Update Auth");
                act(() => {
                    updateButton.click();
                });

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(screen.getByTestId("user-name")).toHaveTextContent("Updated User");
                });
            });

            it("should update axios header when token changes from empty to value", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // State Transition: No token → Token present
                localStorageGetItemSpy.mockReturnValue(null);

                const TestComponent = () => {
                    const [auth, setAuth] = useAuth();
                    return (
                        <button
                            onClick={() => setAuth({
                                user: null,
                                token: "new.bearer.token"
                            })}
                        >
                            Set Token
                        </button>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // Initially no token (empty string from default state)
                expect(axios.defaults.headers.common["Authorization"]).toBe("");

                const setTokenButton = screen.getByText("Set Token");
                act(() => {
                    setTokenButton.click();
                });

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(axios.defaults.headers.common["Authorization"]).toBe("new.bearer.token");
                });
            });

            it("should clear axios header when token changes from value to empty", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // State Transition: Token present → No token (logout scenario)
                const mockAuthData = {
                    user: { name: "Test User" },
                    token: "existing.token"
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                const TestComponent = () => {
                    const [auth, setAuth] = useAuth();
                    return (
                        <div>
                            <div data-testid="current-token">{auth.token || "no-token"}</div>
                            <button
                                onClick={() => setAuth({
                                    user: null,
                                    token: ""
                                })}
                            >
                                Clear Token
                            </button>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // Wait for initial token to load
                await waitFor(() => {
                    expect(screen.getByTestId("current-token")).toHaveTextContent("existing.token");
                });

                const clearButton = screen.getByText("Clear Token");
                act(() => {
                    clearButton.click();
                });

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(screen.getByTestId("current-token")).toHaveTextContent("no-token");
                    expect(axios.defaults.headers.common["Authorization"]).toBe("");
                });
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // SIDE EFFECTS (Communication-Based Testing)
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Side Effects", () => {
            it("should call localStorage.getItem once on mount when no data exists", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Communication-Based Testing: Verify localStorage accessed on mount
                localStorageGetItemSpy.mockReturnValue(null);

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <div>Test</div>
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(localStorageGetItemSpy).toHaveBeenCalledWith("auth");
                    expect(localStorageGetItemSpy).toHaveBeenCalledTimes(1);
                });
            });

            it("should update state from localStorage when data exists", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Communication-Based Testing: Verify state update side effect
                const mockAuthData = {
                    user: { _id: "123", name: "Stored User" },
                    token: "stored.token"
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return <div data-testid="user-name">{auth.user?.name || "no-user"}</div>;
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // State should be updated (side effect of useEffect)
                await waitFor(() => {
                    expect(screen.getByTestId("user-name")).toHaveTextContent("Stored User");
                });
            });

            it("should not update state when localStorage returns null", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Communication-Based Testing: Verify state update does NOT occur
                localStorageGetItemSpy.mockReturnValue(null);

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return (
                        <div>
                            <div data-testid="user">{auth.user === null ? "null" : "not-null"}</div>
                            <div data-testid="token">{auth.token === "" ? "empty" : "not-empty"}</div>
                        </div>
                    );
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // State should remain at default (no update side effect triggered)
                await waitFor(() => {
                    expect(screen.getByTestId("user")).toHaveTextContent("null");
                    expect(screen.getByTestId("token")).toHaveTextContent("empty");
                });
            });

            it("should log error to console when invalid JSON is encountered", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Communication-Based Testing: Verify console.log side effect
                localStorageGetItemSpy.mockReturnValue("{invalid-json}");

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <div>Test</div>
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // SPY Assertion: Verify error was logged to console
                await waitFor(() => {
                    expect(consoleLogSpy).toHaveBeenCalledWith(
                        "Failed to load auth from localStorage:",
                        expect.any(Error)
                    );
                });
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // SECURITY INVARIANTS
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Security Invariants", () => {
            it("should not expose token in error log message when error occurs", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Security Test: Verify sensitive data (token) is not leaked in error logs
                localStorageGetItemSpy.mockReturnValue("{invalid-json-with-secret-token}");

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <div>Test</div>
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                await waitFor(() => {
                    expect(consoleLogSpy).toHaveBeenCalled();
                });

                // Security Assertion: Error message should NOT contain token or sensitive data
                const loggedMessage = consoleLogSpy.mock.calls[0][0];
                expect(loggedMessage).toBe("Failed to load auth from localStorage:");
                expect(loggedMessage).not.toContain("token");
                expect(loggedMessage).not.toContain("secret");
            });

            it("should set axios authorization header to match auth token exactly", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Security Test: Verify header matches token (no manipulation or leakage)
                const expectedToken = "exact.bearer.token.value";
                const mockAuthData = {
                    user: { name: "Test" },
                    token: expectedToken
                };
                localStorageGetItemSpy.mockReturnValue(JSON.stringify(mockAuthData));

                const TestComponent = () => {
                    const [auth] = useAuth();
                    return <div data-testid="token">{auth.token}</div>;
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <TestComponent />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // Security Assertion: axios header must match token exactly (no tampering)
                await waitFor(() => {
                    expect(axios.defaults.headers.common["Authorization"]).toBe(expectedToken);
                    expect(screen.getByTestId("token")).toHaveTextContent(expectedToken);
                });
            });
        });
    });

    // ══════════════════════════════════════════════════════════════════════════════
    // USEAUTH HOOK TESTS
    // ══════════════════════════════════════════════════════════════════════════════

    describe("useAuth", () => {
        let localStorageGetItemSpy;

        beforeEach(() => {
            localStorageGetItemSpy = jest.spyOn(Storage.prototype, "getItem");
            axios.defaults.headers.common = {};
        });

        afterEach(() => {
            jest.clearAllMocks();
            localStorageGetItemSpy.mockRestore();
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // HAPPY PATH
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Happy Path", () => {
            it("should return auth state and setAuth function when used inside AuthProvider", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // EP: Valid usage - hook called within provider
                localStorageGetItemSpy.mockReturnValue(null);

                const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>;

                // ── ACT ──────────────────────────────────────────────────────────────
                const { result } = renderHook(() => useAuth(), { wrapper });

                // ── ASSERT ───────────────────────────────────────────────────────────
                expect(result.current).toBeDefined();
                expect(Array.isArray(result.current)).toBe(true);
                expect(result.current).toHaveLength(2);

                const [auth, setAuth] = result.current;
                expect(auth).toEqual({ user: null, token: "" });
                expect(typeof setAuth).toBe("function");
            });

            it("should return updated state after setAuth is called", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // State Transition: Update auth via setAuth
                localStorageGetItemSpy.mockReturnValue(null);

                const wrapper = ({ children }) => <AuthProvider>{children}</AuthProvider>;
                const { result } = renderHook(() => useAuth(), { wrapper });

                const newAuthState = {
                    user: { _id: "123", name: "New User" },
                    token: "new.token.value"
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                act(() => {
                    const [, setAuth] = result.current;
                    setAuth(newAuthState);
                });

                // ── ASSERT ───────────────────────────────────────────────────────────
                const [auth] = result.current;
                expect(auth).toEqual(newAuthState);
                expect(auth.user.name).toBe("New User");
                expect(auth.token).toBe("new.token.value");
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // ERROR HANDLING
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Error Handling", () => {
            it("should throw helpful error when used outside AuthProvider", () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // EP: Invalid usage - hook called without provider (context is undefined)
                // Error Guessing: Common mistake is using hook outside provider

                // ── ACT & ASSERT ─────────────────────────────────────────────────────
                // renderHook without wrapper → context is undefined
                expect(() => {
                    renderHook(() => useAuth());
                }).toThrow("useAuth must be used within an AuthProvider");
            });
        });

        // ══════════════════════════════════════════════════════════════════════════════
        // SIDE EFFECTS (Multi-Consumer Testing)
        // ══════════════════════════════════════════════════════════════════════════════

        describe("Side Effects", () => {
            it("should provide same state reference to multiple components", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Communication-Based Testing: Verify shared state across consumers
                localStorageGetItemSpy.mockReturnValue(null);

                const Component1 = () => {
                    const [auth] = useAuth();
                    return <div data-testid="component1-token">{auth.token || "no-token"}</div>;
                };

                const Component2 = () => {
                    const [auth] = useAuth();
                    return <div data-testid="component2-token">{auth.token || "no-token"}</div>;
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <Component1 />
                        <Component2 />
                    </AuthProvider>
                );

                // ── ASSERT ───────────────────────────────────────────────────────────
                // Both components should see same initial state
                expect(screen.getByTestId("component1-token")).toHaveTextContent("no-token");
                expect(screen.getByTestId("component2-token")).toHaveTextContent("no-token");
            });

            it("should propagate state updates to all consumers when one component calls setAuth", async () => {
                // ── ARRANGE ──────────────────────────────────────────────────────────
                // Communication-Based Testing: Verify state update propagation
                localStorageGetItemSpy.mockReturnValue(null);

                const Component1 = () => {
                    const [auth, setAuth] = useAuth();
                    return (
                        <div>
                            <div data-testid="component1-user">{auth.user?.name || "no-user"}</div>
                            <button
                                onClick={() => setAuth({
                                    user: { name: "Shared User" },
                                    token: "shared.token"
                                })}
                            >
                                Update
                            </button>
                        </div>
                    );
                };

                const Component2 = () => {
                    const [auth] = useAuth();
                    return <div data-testid="component2-user">{auth.user?.name || "no-user"}</div>;
                };

                // ── ACT ──────────────────────────────────────────────────────────────
                render(
                    <AuthProvider>
                        <Component1 />
                        <Component2 />
                    </AuthProvider>
                );

                const updateButton = screen.getByText("Update");
                act(() => {
                    updateButton.click();
                });

                // ── ASSERT ───────────────────────────────────────────────────────────
                // Both components should see the updated state
                await waitFor(() => {
                    expect(screen.getByTestId("component1-user")).toHaveTextContent("Shared User");
                    expect(screen.getByTestId("component2-user")).toHaveTextContent("Shared User");
                });
            });
        });
    });
});
