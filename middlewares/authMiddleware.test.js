// AI Policy : the following file is generated by AI

/**
 * Unit Tests: authMiddleware
 *
 * Units Under Test:
 *   1. requireSignIn (authMiddleware.js:5-16)
 *   2. isAdmin (authMiddleware.js:19-38)
 *
 * Test Doubles:
 *   - JWT.verify: Stub (returns decoded token or throws)
 *   - userModel.findById: Stub (returns user object or throws)
 *   - req/res/next: Fakes/Mocks
 *
 * Techniques: EP, BVA, Error Guessing, Decision Table, Side Effects, Security
 */

import { requireSignIn, isAdmin } from './authMiddleware.js';
import JWT from 'jsonwebtoken';
import userModel from '../models/userModel.js';

jest.mock('jsonwebtoken');
jest.mock('../models/userModel.js');

describe('authMiddleware', () => {

  // Helper functions for creating test doubles
  const createMockReq = (overrides = {}) => ({
    headers: {},
    user: undefined,
    ...overrides
  });

  const createMockRes = () => {
    const res = {};
    res.status = jest.fn().mockReturnValue(res);
    res.send = jest.fn().mockReturnValue(res);
    return res;
  };

  beforeEach(() => {
    jest.clearAllMocks();
    process.env.JWT_SECRET = 'test-secret-key';
  });

  // ═══════════════════════════════════════════════════
  // UNIT 1: requireSignIn
  // ═══════════════════════════════════════════════════

  describe('requireSignIn', () => {
    const MOCK_IAT = 1234567890;       // Mock issued-at timestamp
    const SEVEN_DAYS_SECONDS = 604800; // JWT expiry: 7 days in seconds

    describe('Happy Path', () => {
      const decodedToken = {
        _id: 'user123',
        iat: 1234567890,
        exp: 1234567890 + 604800
      };

      it('should set req.user and call next when token is valid', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'valid-jwt-token' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockReturnValue(decodedToken);

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(req.user).toEqual(decodedToken);
        expect(next).toHaveBeenCalledTimes(1);
      });
    });

    describe('Equivalence Partitions — Missing/Invalid Token', () => {
      let res, next;

      beforeEach(() => {
        res = createMockRes();
        next = jest.fn();
        JWT.verify.mockImplementation(() => {
          throw new Error('jwt must be provided');
        });
      });

      it('should return 401 when header is missing', async () => {
        // ── ARRANGE ──
        const req = createMockReq(); // No authorization header

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });

      it('should return 401 when header is undefined', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: undefined } });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });

      it('should return 401 when header is null', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: null } });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });

      it('should return 401 when header is empty string', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: '' } });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });
    });

    describe('Error Handling — JWT Failures', () => {
      let res, next;

      beforeEach(() => {
        res = createMockRes();
        next = jest.fn();
      });

      it('should return 401 error when token is malformed', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: 'malformed.token.here' } });
        JWT.verify.mockImplementation(() => { throw new Error('jwt malformed'); });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });

      it('should return 401 error when token is expired', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: 'expired.jwt.token' } });
        JWT.verify.mockImplementation(() => {
          const error = new Error('jwt expired');
          error.name = 'TokenExpiredError';
          throw error;
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });

      it('should return 401 error when signature is invalid', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: 'token.with.invalid.signature' } });
        JWT.verify.mockImplementation(() => {
          const error = new Error('invalid signature');
          error.name = 'JsonWebTokenError';
          throw error;
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });

      it('should return 401 error when algorithm is wrong', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: 'token.with.wrong.algorithm' } });
        JWT.verify.mockImplementation(() => {
          const error = new Error('invalid algorithm');
          error.name = 'JsonWebTokenError';
          throw error;
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });

      it('should return 401 error when generic JWT error occurs', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ headers: { authorization: 'some.jwt.token' } });
        JWT.verify.mockImplementation(() => { throw new Error('Unexpected JWT error'); });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
      });
    });

    describe('Security Invariants', () => {

      it('should preserve all token fields including custom fields when assigning to req.user', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'valid-jwt-token' }
        });
        const res = createMockRes();
        const next = jest.fn();

        // Token with standard fields plus custom fields to verify complete preservation
        const decodedToken = {
          _id: 'user123',
          iat: MOCK_IAT,
          exp: MOCK_IAT + SEVEN_DAYS_SECONDS,
          customField: 'custom-value',
          role: 'admin'
        };
        JWT.verify.mockReturnValue(decodedToken);

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        // Verify all fields are preserved, not just standard JWT fields
        expect(req.user).toEqual(decodedToken);
        expect(req.user.customField).toBe('custom-value');
        expect(req.user.role).toBe('admin');
      });
    });
  });

  // ═══════════════════════════════════════════════════
  // UNIT 2: isAdmin
  // ═══════════════════════════════════════════════════

  describe('isAdmin', () => {

    describe('Happy Path', () => {

      it('should call next when user is admin', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'admin123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const adminUser = {
          _id: 'admin123',
          name: 'Admin User',
          email: 'admin@example.com',
          role: 1
        };
        userModel.findById.mockResolvedValue(adminUser);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(next).toHaveBeenCalledTimes(1);
      });
    });

    describe('Boundary Values — Role Authorization', () => {
      let req, res, next;

      beforeEach(() => {
        req = createMockReq({ user: { _id: 'user123' } });
        res = createMockRes();
        next = jest.fn();
      });

      it('should return 401 when role is 0', async () => {
        // ── ARRANGE ──
        userModel.findById.mockResolvedValue({
          _id: 'user123', name: 'Regular User', email: 'user@example.com', role: 0
        });

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
      });

      it('should return 401 when role is 2', async () => {
        // ── ARRANGE ──
        userModel.findById.mockResolvedValue({
          _id: 'user123', name: 'User', email: 'user@example.com', role: 2
        });

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
      });

      it('should return 401 when role is -1', async () => {
        // ── ARRANGE ──
        userModel.findById.mockResolvedValue({
          _id: 'user123', name: 'User', email: 'user@example.com', role: -1
        });

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
      });

      it('should return 401 when role is undefined', async () => {
        // ── ARRANGE ──
        userModel.findById.mockResolvedValue({
          _id: 'user123', name: 'User', email: 'user@example.com', role: undefined
        });

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
      });

      it('should return 401 when role is null', async () => {
        // ── ARRANGE ──
        userModel.findById.mockResolvedValue({
          _id: 'user123', name: 'User', email: 'user@example.com', role: null
        });

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
      });
    });

    describe('Equivalence Partitions — Missing req.user._id', () => {
      let res, next;

      beforeEach(() => {
        res = createMockRes();
        next = jest.fn();
      });

      it('should return 401 error when req.user._id is undefined', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ user: { _id: undefined } });
        userModel.findById.mockRejectedValue(new Error('User ID is required'));

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
      });

      it('should return 401 error when req.user._id is null', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ user: { _id: null } });
        userModel.findById.mockRejectedValue(new Error('User ID is required'));

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
      });

      it('should return 401 error when req.user is missing', async () => {
        // ── ARRANGE ──
        const req = createMockReq(); // No user property at all

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
      });
    });

    describe('Error Handling — Database Failures', () => {
      let res, next;

      beforeEach(() => {
        res = createMockRes();
        next = jest.fn();
      });

      it('should return 401 error when findById returns null', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ user: { _id: 'deleted-user-123' } });
        userModel.findById.mockResolvedValue(null);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
      });

      it('should return 401 error when database error occurs', async () => {
        // ── ARRANGE ──
        const req = createMockReq({ user: { _id: 'user123' } });
        const dbError = new Error('Database connection failed');
        userModel.findById.mockRejectedValue(dbError);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          error: dbError,
          message: "Error in admin middleware"
        });
      });
    });

  });
});

