// AI Policy : the following file is generated by AI

/**
 * Unit Tests: authMiddleware
 *
 * Units Under Test:
 *   1. requireSignIn (authMiddleware.js:5-16)
 *   2. isAdmin (authMiddleware.js:19-38)
 *
 * Test Doubles:
 *   - JWT.verify: Stub (returns decoded token or throws)
 *   - userModel.findById: Stub (returns user object or throws)
 *   - req/res/next: Fakes/Mocks
 *
 * Techniques: EP, BVA, Error Guessing, Decision Table, Side Effects, Security
 */

import { requireSignIn, isAdmin } from './authMiddleware.js';
import JWT from 'jsonwebtoken';
import userModel from '../models/userModel.js';

jest.mock('jsonwebtoken');
jest.mock('../models/userModel.js');

describe('authMiddleware', () => {

  // Helper functions for creating test doubles
  const createMockReq = (overrides = {}) => ({
    headers: {},
    user: undefined,
    ...overrides
  });

  const createMockRes = () => {
    const res = {};
    res.status = jest.fn().mockReturnValue(res);
    res.send = jest.fn().mockReturnValue(res);
    return res;
  };

  beforeEach(() => {
    jest.clearAllMocks();
    process.env.JWT_SECRET = 'test-secret-key';
  });

  // ═══════════════════════════════════════════════════
  // UNIT 1: requireSignIn
  // ═══════════════════════════════════════════════════

  describe('requireSignIn', () => {

    describe('Happy Path', () => {

      it('should set req.user and call next when token is valid', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'valid-jwt-token' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const decodedToken = {
          _id: 'user123',
          iat: 1234567890,
          exp: 1234567890 + 604800
        };
        JWT.verify.mockReturnValue(decodedToken);

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(req.user).toEqual(decodedToken);
        expect(next).toHaveBeenCalledTimes(1);
        expect(res.status).not.toHaveBeenCalled();
      });
    });

    describe('Equivalence Partitions — Missing/Invalid Token', () => {

      it('should return 401 error when authorization header is missing', async () => {
        // ── ARRANGE ──
        const req = createMockReq(); // No authorization header
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          throw new Error('jwt must be provided');
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when authorization header is undefined', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: undefined }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          throw new Error('jwt must be provided');
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when authorization header is null', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: null }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          throw new Error('jwt must be provided');
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when authorization is empty string', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: '' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          throw new Error('jwt must be provided');
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });
    });

    describe('Error Handling — JWT Failures', () => {

      it('should return 401 error when token is malformed', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'malformed.token.here' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          throw new Error('jwt malformed');
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when token is expired', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'expired.jwt.token' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          const error = new Error('jwt expired');
          error.name = 'TokenExpiredError';
          throw error;
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when signature is invalid', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'token.with.invalid.signature' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          const error = new Error('invalid signature');
          error.name = 'JsonWebTokenError';
          throw error;
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when algorithm is wrong', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'token.with.wrong.algorithm' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          const error = new Error('invalid algorithm');
          error.name = 'JsonWebTokenError';
          throw error;
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when generic JWT error occurs', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'some.jwt.token' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          throw new Error('Unexpected JWT error');
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid or expired token"
        });
        expect(next).not.toHaveBeenCalled();
      });
    });

    describe('Side Effects', () => {

      it('should call JWT.verify with correct arguments when token is valid', async () => {
        // ── ARRANGE ──
        const token = 'valid-jwt-token';
        const req = createMockReq({
          headers: { authorization: token }
        });
        const res = createMockRes();
        const next = jest.fn();

        const decodedToken = { _id: 'user123', iat: 1234567890, exp: 1234567890 + 604800 };
        JWT.verify.mockReturnValue(decodedToken);

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(JWT.verify).toHaveBeenCalledWith(token, 'test-secret-key');
        expect(JWT.verify).toHaveBeenCalledTimes(1);
      });

      it('should not call next when token is invalid', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'invalid-token' }
        });
        const res = createMockRes();
        const next = jest.fn();

        JWT.verify.mockImplementation(() => {
          throw new Error('invalid token');
        });

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        expect(next).not.toHaveBeenCalled();
      });
    });

    describe('Security Invariants', () => {

      it('should preserve all token fields including custom fields when assigning to req.user', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          headers: { authorization: 'valid-jwt-token' }
        });
        const res = createMockRes();
        const next = jest.fn();

        // Token with standard fields plus custom fields to verify complete preservation
        const decodedToken = {
          _id: 'user123',
          iat: 1234567890,
          exp: 1234567890 + 604800,
          customField: 'custom-value',
          role: 'admin'
        };
        JWT.verify.mockReturnValue(decodedToken);

        // ── ACT ──
        await requireSignIn(req, res, next);

        // ── ASSERT ──
        // Verify all fields are preserved, not just standard JWT fields
        expect(req.user).toEqual(decodedToken);
        expect(req.user.customField).toBe('custom-value');
        expect(req.user.role).toBe('admin');
      });
    });
  });

  // ═══════════════════════════════════════════════════
  // UNIT 2: isAdmin
  // ═══════════════════════════════════════════════════

  describe('isAdmin', () => {

    describe('Happy Path', () => {

      it('should call next when user is admin', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'admin123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const adminUser = {
          _id: 'admin123',
          name: 'Admin User',
          email: 'admin@example.com',
          role: 1
        };
        userModel.findById.mockResolvedValue(adminUser);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(next).toHaveBeenCalledTimes(1);
        expect(res.status).not.toHaveBeenCalled();
      });
    });

    describe('Boundary Values — Role Authorization', () => {

      it('should return 401 unauthorized access when user role is zero', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const regularUser = {
          _id: 'user123',
          name: 'Regular User',
          email: 'user@example.com',
          role: 0
        };
        userModel.findById.mockResolvedValue(regularUser);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 unauthorized access when user role is two', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const userWithRoleTwo = {
          _id: 'user123',
          name: 'User',
          email: 'user@example.com',
          role: 2
        };
        userModel.findById.mockResolvedValue(userWithRoleTwo);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 unauthorized access when user role is negative one', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const userWithNegativeRole = {
          _id: 'user123',
          name: 'User',
          email: 'user@example.com',
          role: -1
        };
        userModel.findById.mockResolvedValue(userWithNegativeRole);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 unauthorized access when user role is undefined', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const userWithUndefinedRole = {
          _id: 'user123',
          name: 'User',
          email: 'user@example.com',
          role: undefined
        };
        userModel.findById.mockResolvedValue(userWithUndefinedRole);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 unauthorized access when user role is null', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const userWithNullRole = {
          _id: 'user123',
          name: 'User',
          email: 'user@example.com',
          role: null
        };
        userModel.findById.mockResolvedValue(userWithNullRole);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
        expect(next).not.toHaveBeenCalled();
      });
    });

    describe('Equivalence Partitions — Missing req.user._id', () => {

      it('should return 401 error when req.user._id is undefined', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: undefined }
        });
        const res = createMockRes();
        const next = jest.fn();

        userModel.findById.mockRejectedValue(new Error('User ID is required'));

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when req.user._id is null', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: null }
        });
        const res = createMockRes();
        const next = jest.fn();

        userModel.findById.mockRejectedValue(new Error('User ID is required'));

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when req.user is missing', async () => {
        // ── ARRANGE ──
        const req = createMockReq(); // No user property at all
        const res = createMockRes();
        const next = jest.fn();

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
        expect(next).not.toHaveBeenCalled();
      });
    });

    describe('Error Handling — Database Failures', () => {

      it('should return 401 error when findById returns null', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'deleted-user-123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        userModel.findById.mockResolvedValue(null);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: false,
            message: "Error in admin middleware"
          })
        );
        expect(next).not.toHaveBeenCalled();
      });

      it('should return 401 error when database error occurs', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const dbError = new Error('Database connection failed');
        userModel.findById.mockRejectedValue(dbError);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          error: dbError,
          message: "Error in admin middleware"
        });
        expect(next).not.toHaveBeenCalled();
      });
    });

    describe('Side Effects', () => {

      it('should call findById with correct id when user is valid admin', async () => {
        // ── ARRANGE ──
        const userId = 'admin-xyz-789';
        const req = createMockReq({
          user: { _id: userId }
        });
        const res = createMockRes();
        const next = jest.fn();

        const adminUser = {
          _id: userId,
          name: 'Admin',
          email: 'admin@example.com',
          role: 1
        };
        userModel.findById.mockResolvedValue(adminUser);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(userModel.findById).toHaveBeenCalledWith(userId);
        expect(userModel.findById).toHaveBeenCalledTimes(1);
      });

      it('should not call next when user is non-admin', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        userModel.findById.mockResolvedValue({ role: 0 });

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(next).not.toHaveBeenCalled();
      });

      it('should not call next when database error occurs', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        userModel.findById.mockRejectedValue(new Error('DB error'));

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(next).not.toHaveBeenCalled();
      });
    });

    describe('Security Invariants', () => {

      it('should have correct structure in non-admin response', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        userModel.findById.mockResolvedValue({ role: 0 });

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "UnAuthorized Access"
        });
        const responseData = res.send.mock.calls[0][0];
        expect(responseData).toHaveProperty('success', false);
        expect(responseData).toHaveProperty('message', "UnAuthorized Access");
      });

      it('should have correct structure in error response', async () => {
        // ── ARRANGE ──
        const req = createMockReq({
          user: { _id: 'user123' }
        });
        const res = createMockRes();
        const next = jest.fn();

        const dbError = new Error('Database error');
        userModel.findById.mockRejectedValue(dbError);

        // ── ACT ──
        await isAdmin(req, res, next);

        // ── ASSERT ──
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          error: dbError,
          message: "Error in admin middleware"
        });
        const responseData = res.send.mock.calls[0][0];
        expect(responseData).toHaveProperty('success', false);
        expect(responseData).toHaveProperty('error');
        expect(responseData).toHaveProperty('message', "Error in admin middleware");
      });
    });
  });
});
