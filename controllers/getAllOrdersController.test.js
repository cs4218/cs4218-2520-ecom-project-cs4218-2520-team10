// File Created - YAN WEIDONG A0258151H
/**
 * NOTE: The following tests and documentation are generated by AI based on user provided scenario plan.
 */
import { getAllOrdersController } from "./authController.js";
import orderModel from "../models/orderModel.js";

jest.mock("../models/orderModel.js", () => ({
  find: jest.fn().mockReturnThis(),
  populate: jest.fn().mockReturnThis(),
  sort: jest.fn().mockReturnThis(),
  exec: jest.fn(),
  then: jest.fn((resolve) => resolve([])),
}));

/**
 * Unit Tests for getAllOrdersController
 *
 * Test Strategy: Output-based
 *
 * Test Doubles Used:
 * - orderModel:                STUB (controls find, populate, sort, exec behavior)
 * - req/res:                   FAKE (test doubles for Express request/response objects)
 *
 * Testing Techniques Applied:
 * - Happy Path: User with orders, user with no orders
 * - Negative Testing: Database errors
 * - Interaction Testing: Verifying `orderModel` methods are called with correct arguments
 *
 * Scenario Plan:
 * #  | Category       | Technique    | Scenario                                          | Expected Result
 * ---|----------------|--------------|---------------------------------------------------|-----------------------------------------------------
 * 1  | Happy Path     | —            | Successfully retrieves multiple orders            | 200 Success, returns array of populated orders, sorted by `createdAt` descending
 * 2  | Happy Path     | —            | Successfully retrieves no orders                  | 200 Success, returns empty array
 * 3  | Error Handling | Negative     | orderModel.find rejects                           | 500 Internal Server Error, message: "Error While Getting Orders", error logged
 */
describe("getAllOrdersController", () => {
  let req, res;

  beforeEach(() => {
    jest.clearAllMocks();
    req = {}; // No req.user needed for getAllOrdersController
    res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
      send: jest.fn(),
    };

    // Reset orderModel mocks for each test
    orderModel.find.mockReturnThis();
    orderModel.populate.mockReturnThis();
    orderModel.sort.mockReturnThis();
    // Make the chain resolve to an empty array by default
    orderModel.then.mockImplementation((resolve) => resolve([]));
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe("Happy Path", () => {
    it("should return 200 with populated orders when multiple orders exist", async () => {
      // ── ARRANGE ──────────────────────────────────
      const mockOrders = [
        {
          _id: "orderA",
          products: [{ name: "Product X" }],
          buyer: { name: "Buyer 1" },
          createdAt: new Date("2024-01-15T10:00:00Z"),
        },
        {
          _id: "orderB",
          products: [{ name: "Product Y" }],
          buyer: { name: "Buyer 2" },
          createdAt: new Date("2024-01-14T10:00:00Z"),
        },
      ];
      orderModel.then.mockImplementation((resolve) => resolve(mockOrders));

      // ── ACT ──────────────────────────────────────
      await getAllOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(orderModel.find).toHaveBeenCalledWith({});
      expect(orderModel.populate).toHaveBeenCalledWith("products", "-photo");
      expect(orderModel.populate).toHaveBeenCalledWith("buyer", "name");
      expect(orderModel.sort).toHaveBeenCalledWith({ createdAt: -1 });
      expect(res.json).toHaveBeenCalledWith(mockOrders);
      expect(res.status).not.toHaveBeenCalledWith(500); // Ensure no error status
    });

    it("should return 200 with an empty array when no orders exist", async () => {
      // ── ARRANGE ──────────────────────────────────
      orderModel.then.mockImplementation((resolve) => resolve([]));

      // ── ACT ──────────────────────────────────────
      await getAllOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(orderModel.find).toHaveBeenCalledWith({});
      expect(orderModel.populate).toHaveBeenCalledWith("products", "-photo");
      expect(orderModel.populate).toHaveBeenCalledWith("buyer", "name");
      expect(orderModel.sort).toHaveBeenCalledWith({ createdAt: -1 });
      expect(res.json).toHaveBeenCalledWith([]);
      expect(res.status).not.toHaveBeenCalledWith(500); // Ensure no error status
    });
  });

  describe("Error Handling", () => {
    it("should return 500 when database operation fails", async () => {
      // ── ARRANGE ──────────────────────────────────
      const dbError = new Error("Database query failed during getAllOrders");
      orderModel.then.mockImplementation((resolve, reject) => reject(dbError));

      // ── ACT ──────────────────────────────────────
      await getAllOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.send).toHaveBeenCalledWith(
        expect.objectContaining({
          success: false,
          message: "Error While Getting Orders",
        }),
      );
    });
  });
});
