// AI Policy : the following file is generated by AI
// Test cases written by: KIM SHI TONG A0265858J

/**
 * Test Suite: forgotPasswordController
 *
 * Purpose: Validates password reset functionality including input validation,
 * user lookup, password hashing, and database updates.
 *
 * Testing Techniques Applied:
 * - Equivalence Partitioning (EP): Valid/invalid input partitions
 * - Boundary Value Analysis (BVA): Empty strings, null, undefined
 * - Decision Table Testing: All condition combinations
 * - Error Guessing: Database failures, hash failures
 * - State Transition Testing: Validation → Lookup → Hash → Update flow
 * - Communication-Based Testing: Side effect verification
 * - Security Testing: User enumeration vulnerability documentation
 *
 * @see authController.js:forgotPasswordController (lines 120-155)
 *
 * Decision Table - forgotPasswordController flow:
 * |         | Rule 1 | Rule 2 | Rule 3 | Rule 4 |
 * |---------|--------|--------|--------|--------|
 * | C1: input valid?     | N      | Y      | Y      | Y      |
 * | C2: user found?      | -      | N      | Y      | Y      |
 * | C3: hash success?    | -      | -      | N      | Y      |
 * |---------|--------|--------|--------|--------|
 * | A1: 400 validation   | X      |        |        |        |
 * | A2: 404 not found    |        | X      |        |        |
 * | A3: 500 hash error   |        |        | X      |        |
 * | A4: 200 success      |        |        |        | X      |
 */

import { forgotPasswordController } from './authController.js';
import userModel from '../models/userModel.js';
import { hashPassword } from '../helpers/authHelper.js';

// Mock dependencies
jest.mock('../models/userModel.js');
jest.mock('../helpers/authHelper.js');

describe('AuthController', () => {
  describe('forgotPasswordController', () => {
    let req;
    let res;
    let mockUser;

    beforeEach(() => {
      // Setup mock user object
      mockUser = {
        _id: '507f1f77bcf86cd799439011',
        name: 'Test User',
        email: 'test@example.com',
        phone: '1234567890',
        address: { street: '123 Test St', city: 'Test City' },
        role: 0,
        password: '$2b$10$oldHashedPassword',
        answer: 'test security answer',
      };

      // Setup request and response mocks
      req = {
        body: {}
      };

      res = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn().mockReturnThis(),
      };

      // Reset all mocks
      jest.clearAllMocks();
    });

    afterEach(() => {
      jest.clearAllMocks();
    });

    // ============================================================================
    // HAPPY PATH (EP: Valid Partition)
    // ============================================================================

    describe('Happy Path', () => {
      it('should return 200 with success message', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(mockUser);
        hashPassword.mockResolvedValue('$2b$10$newHashedPassword');
        userModel.findByIdAndUpdate.mockResolvedValue(mockUser);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(200);
        expect(res.send).toHaveBeenCalledWith({
          success: true,
          message: 'Password Reset Successfully'
        });
      });
    });

    // ============================================================================
    // INPUT VALIDATION (EP: Invalid Partition + BVA)
    // ============================================================================

    describe('Boundary Values', () => {
      it('should return 400 when email is missing', async () => {
        // Arrange
        req.body = {
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(400);
        expect(res.send).toHaveBeenCalledWith({
          message: 'Email is required'
        });
      });

      it('should return 400 when answer is missing', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          newPassword: 'newPassword123'
        };

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(400);
        expect(res.send).toHaveBeenCalledWith({
          message: 'Answer is required'
        });
      });

      it('should return 400 when new password is missing', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer'
        };

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(400);
        expect(res.send).toHaveBeenCalledWith({
          message: 'New Password is required'
        });
      });

      it('should return 400 when all fields are missing', async () => {
        // Arrange
        req.body = {};

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(400);
        expect(res.send).toHaveBeenCalledWith({
          message: 'Email is required'
        });
      });

      it('should return 400 when email is empty', async () => {
        // Arrange - BVA: empty string
        req.body = {
          email: '',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(400);
        expect(res.send).toHaveBeenCalledWith({
          message: 'Email is required'
        });
      });

      it('should return 400 when email is null', async () => {
        // Arrange - BVA: null value
        req.body = {
          email: null,
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(400);
        expect(res.send).toHaveBeenCalledWith({
          message: 'Email is required'
        });
      });

      it('should return 404 when user is not found', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'wrong answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(null);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: 'Wrong Email Or Answer'
        });
      });
    });

    // ============================================================================
    // ERROR HANDLING (Error Guessing: Dependency Failures)
    // ============================================================================

    describe('Error Handling', () => {
      it('should return 500 when database query fails', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        const dbError = new Error('Database connection failed');
        userModel.findOne.mockRejectedValue(dbError);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: 'Something went wrong',
          error: dbError
        });
      });

      it('should return 500 when password hashing fails', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(mockUser);
        const hashError = new Error('Hashing failed');
        hashPassword.mockRejectedValue(hashError);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: 'Something went wrong',
          error: hashError
        });
      });

      it('should return 500 when database update fails', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(mockUser);
        hashPassword.mockResolvedValue('$2b$10$newHashedPassword');
        const updateError = new Error('Update failed');
        userModel.findByIdAndUpdate.mockRejectedValue(updateError);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: 'Something went wrong',
          error: updateError
        });
      });
    });

    // ============================================================================
    // SIDE EFFECTS (Communication-Based Testing)
    // ============================================================================

    describe('Side Effects', () => {
      it('should call findOne with email and answer when input is valid', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(mockUser);
        hashPassword.mockResolvedValue('$2b$10$newHashedPassword');
        userModel.findByIdAndUpdate.mockResolvedValue(mockUser);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(userModel.findOne).toHaveBeenCalledWith({
          email: 'test@example.com',
          answer: 'test security answer'
        });
      });

      it('should call hashPassword with new password when input is valid', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(mockUser);
        hashPassword.mockResolvedValue('$2b$10$newHashedPassword');
        userModel.findByIdAndUpdate.mockResolvedValue(mockUser);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(hashPassword).toHaveBeenCalledWith('newPassword123');
      });

      it('should call findByIdAndUpdate with hashed password on success', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(mockUser);
        hashPassword.mockResolvedValue('$2b$10$newHashedPassword');
        userModel.findByIdAndUpdate.mockResolvedValue(mockUser);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(userModel.findByIdAndUpdate).toHaveBeenCalledWith(
          mockUser._id,
          { password: '$2b$10$newHashedPassword' }
        );
      });

      it('should not call findOne when email is missing', async () => {
        // Arrange
        req.body = {
          answer: 'test security answer',
          newPassword: 'newPassword123'
        };

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(userModel.findOne).not.toHaveBeenCalled();
      });

      it('should not call hashPassword when user is not found', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'wrong answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(null);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(hashPassword).not.toHaveBeenCalled();
      });

      it('should not call findByIdAndUpdate when user is not found', async () => {
        // Arrange
        req.body = {
          email: 'test@example.com',
          answer: 'wrong answer',
          newPassword: 'newPassword123'
        };

        userModel.findOne.mockResolvedValue(null);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(userModel.findByIdAndUpdate).not.toHaveBeenCalled();
      });
    });

    // ============================================================================
    // SECURITY INVARIANTS
    // ============================================================================

    describe('Security Invariants', () => {
      /**
       * SECURITY VULNERABILITY DOCUMENTATION:
       *
       * The following tests document a user enumeration vulnerability in the current implementation.
       *
       * Issue: The error message "Wrong Email Or Answer" is returned when findOne({email, answer})
       * returns null. This could mean either:
       * 1. Email doesn't exist in the system
       * 2. Email exists but answer is wrong
       *
       * Current behavior: The compound query (email AND answer) returns the same error message
       * for both scenarios, which might seem secure. However, timing attacks or database-level
       * behavior could still leak information about which emails exist in the system.
       *
       * Recommended improvement:
       * - Check if email exists first (separate query)
       * - If email doesn't exist, return generic error
       * - If email exists but answer is wrong, return the SAME generic error
       * - Use constant-time comparison where possible
       * - Add rate limiting to prevent brute force attacks
       *
       * Example improved flow:
       * 1. const user = await userModel.findOne({ email });
       * 2. if (!user || user.answer !== answer) {
       *      return res.status(404).send({ message: "Invalid credentials" });
       *    }
       */

      it('should return 404 with generic message when email does not exist', async () => {
        // Arrange
        req.body = {
          email: 'nonexistent@example.com',
          answer: 'any answer',
          newPassword: 'newPassword123'
        };
        userModel.findOne.mockResolvedValue(null);

        // Act
        await forgotPasswordController(req, res);

        // Assert
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: 'Wrong Email Or Answer'
        });
      });

      it('should return same message for wrong answer as wrong email', async () => {
        // Arrange - Note: Current implementation doesn't distinguish wrong answer
        req.body = {
          email: 'test@example.com',
          answer: 'wrong answer',
          newPassword: 'newPassword123'
        };
        userModel.findOne.mockResolvedValue(null);

        // Act
        await forgotPasswordController(req, res);

        // Assert - Same generic message prevents user enumeration
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: 'Wrong Email Or Answer'
        });
      });
    });
  });
});