// File Created - YAN WEIDONG A0258151H
/**
 * NOTE: The following tests and documentation are generated by AI based on user provided scenario plan.
 */
import { getOrdersController } from "./authController.js";
import orderModel from "../models/orderModel.js";

jest.mock("../models/orderModel.js", () => ({
  find: jest.fn().mockReturnThis(),
  populate: jest.fn().mockReturnThis(),
  sort: jest.fn().mockReturnThis(),
  exec: jest.fn(),
  then: jest.fn((resolve) => resolve([])),
}));

/**
 * Unit Tests for getOrdersController
 *
 * Test Strategy: Output-based testing
 *
 * Test Doubles Used:
 * - orderModel:                STUB (returns controlled responses for database queries)
 * - req/res:                   FAKE (test doubles for Express request/response objects)
 *
 * Testing Techniques Applied:
 * - EP: Invalid (Unauthorized access, missing user ID)
 * - EP: Valid (User with single order, user with multiple orders, user with no orders)
 * - Negative Testing: Unauthorized access, database errors
 *
 * Scenario Plan:
 * #  | Category        | Technique                    | Scenario                                          | Expected Result
 * ---|-----------------|------------------------------|---------------------------------------------------|-----------------------------------------------------
 * 1  | Happy Path      | EP + BVA (Valid - Zero)      | User has no orders                                | 200 Success, returns empty array
 * 2  | Happy Path      | EP + BVA (Valid - Single)    | User has single order                             | 200 Success, returns array of order
 * 3  | Happy Path      | EP + BVA (Valid - Multiple)  | User has multiple orders                          | 200 Success, returns array of orders
 * 4  | Happy Path      | Data Integrity Testing       | Orders include populated product details          | 200 Success, returns orders with product information
 * 5  | Happy Path      | Data Integrity Testing       | Orders include populated buyer information        | 200 Success, returns orders with buyer name
 * 6  | Error Handling  | Negative Testing             | Database operation fails                          | 500 Internal Server Error, error message returned
 */
describe("getOrdersController", () => {
  let req, res;
  const mockUserId = "user123";

  beforeEach(() => {
    jest.clearAllMocks();
    req = {
      user: { _id: mockUserId },
    };
    res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
      send: jest.fn(),
    };

    // Reset orderModel mocks for each test
    orderModel.find.mockReturnThis();
    orderModel.populate.mockReturnThis();
    orderModel.sort.mockReturnThis();
    // Make the chain resolve to an empty array by default
    orderModel.then.mockImplementation((resolve) => resolve([]));
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe("Happy Path", () => {
    it("should return empty array when user has no orders", async () => {
      // ── ARRANGE ──────────────────────────────────
      orderModel.then.mockImplementation((resolve) => resolve([]));

      // ── ACT ──────────────────────────────────────
      await getOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(res.json).toHaveBeenCalledWith([]);
      const returnedOrders = res.json.mock.calls[0][0];
      expect(returnedOrders).toHaveLength(0);
    });

    it("should return correct orders when user has single order", async () => {
      // ── ARRANGE ──────────────────────────────────
      const mockOrders = [
        {
          _id: "order1",
          buyer: mockUserId,
          products: [{ name: "Product A" }],
          createdAt: new Date("2024-02-12T10:00:00Z"),
        },
      ];
      orderModel.then.mockImplementation((resolve) => resolve(mockOrders));

      // ── ACT ──────────────────────────────────────
      await getOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(res.json).toHaveBeenCalledWith(mockOrders);
      const returnedOrders = res.json.mock.calls[0][0];
      expect(returnedOrders).toHaveLength(1);
    });

    it("should return correct orders when user has multiple orders", async () => {
      // ── ARRANGE ──────────────────────────────────
      const mockOrders = [
        {
          _id: "order1",
          buyer: mockUserId,
          products: [{ name: "Product A" }],
          createdAt: new Date("2024-02-12T10:00:00Z"),
        },
        {
          _id: "order2",
          buyer: mockUserId,
          products: [{ name: "Product B" }],
          createdAt: new Date("2024-02-12T11:00:00Z"),
        },
      ];
      orderModel.then.mockImplementation((resolve) => resolve(mockOrders));

      // ── ACT ──────────────────────────────────────
      await getOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(res.json).toHaveBeenCalledWith(mockOrders);
      const returnedOrders = res.json.mock.calls[0][0];
      expect(returnedOrders).toHaveLength(2);
    });

    it("should return orders with populated product details", async () => {
      // ── ARRANGE ──────────────────────────────────
      const mockOrders = [
        {
          _id: "order1",
          buyer: { _id: mockUserId, name: "John Doe" },
          products: [
            { _id: "prod1", name: "Laptop", price: 999 },
            { _id: "prod2", name: "Mouse", price: 29 },
          ],
          createdAt: new Date("2024-02-12T10:00:00Z"),
        },
      ];
      orderModel.then.mockImplementation((resolve) => resolve(mockOrders));

      // ── ACT ──────────────────────────────────────
      await getOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(res.json).toHaveBeenCalledWith(mockOrders);
      const returnedOrders = res.json.mock.calls[0][0];
      expect(returnedOrders).toHaveLength(1);
      expect(returnedOrders[0].products).toBeDefined();
      expect(returnedOrders[0].products).toHaveLength(2);
    });

    it("should return orders with populated buyer information", async () => {
      // ── ARRANGE ──────────────────────────────────
      const mockBuyerInfo = { _id: mockUserId, name: "Jane Smith" };
      const mockOrders = [
        {
          _id: "order1",
          buyer: mockBuyerInfo,
          products: [{ _id: "prod1", name: "Tablet" }],
          payment: { success: true },
          status: "Processing",
        },
      ];
      orderModel.then.mockImplementation((resolve) => resolve(mockOrders));

      // ── ACT ──────────────────────────────────────
      await getOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(res.json).toHaveBeenCalledWith(mockOrders);
      const returnedOrders = res.json.mock.calls[0][0];
      expect(returnedOrders[0].buyer).toEqual(mockBuyerInfo);
    });
  });

  describe("Error Handling", () => {
    it("should return 500 Internal Server Error when database operation fails", async () => {
      // ── ARRANGE ──────────────────────────────────
      const dbError = new Error("Database query failed");
      orderModel.then.mockImplementation((resolve, reject) => reject(dbError));

      // ── ACT ──────────────────────────────────────
      await getOrdersController(req, res);

      // ── ASSERT ───────────────────────────────────
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.send).toHaveBeenCalledWith(
        expect.objectContaining({
          success: false,
          message: expect.any(String),
          error: dbError,
        }),
      );
    });
  });
});
