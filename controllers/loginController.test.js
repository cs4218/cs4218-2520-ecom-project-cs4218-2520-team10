// AI Policy : the following file is generated by AI
// Test cases written by: KIM SHI TONG A0265858J

/**
 * Unit Tests for loginController
 *
 * Tests authentication logic including:
 * - Input validation (email, password presence)
 * - User lookup and authentication
 * - Password comparison
 * - JWT token generation
 * - Error handling for all failure paths
 * - Response structure and status codes
 *
 * Coverage Target: 100% (lines + functions)
 * Test Strategy: Output-based + Communication-based testing
 *
 * Test Doubles Used:
 * - userModel.findOne:   STUB (returns controlled test data: mockUser or null)
 * - comparePassword:     STUB (returns controlled boolean: true or false)
 * - JWT.sign:            STUB (returns controlled token string)
 * - req/res:             req: Fake, res: Mock (test doubles for Express request/response objects)
 *
 * Testing Techniques Applied:
 * - Equivalence Partitioning (EP): Valid/invalid input partitions
 * - Boundary Value Analysis (BVA): Empty strings, null, undefined values
 * - Decision Table Testing: Coverage of all condition combinations
 * - Error Guessing: Database failures, bcrypt errors, JWT errors
 * - State Transition Testing: Authentication flow state changes
 *
 * Scenario Plan:
 * #  | Category    | Technique | Scenario                        | Expected
 * 1  | Happy       | —         | valid email + correct password   | 200 + token + user
 * 2  | Validation  | EP+BVA    | email: missing / empty / null    | 404 (full variants)
 * 3  | Validation  | EP        | password: missing                | 404
 * 4  | Validation  | EP        | both missing                    | 404
 * 5  | Auth        | DT rule 2 | user not found                  | 404 "not registered"
 * 6  | Auth        | DT rule 3 | password mismatch               | 200 "Invalid Password"
 * 7  | Error       | —         | findOne throws                  | 500
 * 8  | Error       | —         | comparePassword throws           | 500
 * 9  | Error       | —         | JWT.sign throws                 | 500
 * 17 | Security    | —         | success response                | password NOT in user obj
 * 18 | Security    | —         | not found vs wrong pw messages  | document difference
 */

import { loginController } from "./authController.js";
import userModel from "../models/userModel.js";
import { comparePassword } from "../helpers/authHelper.js";
import JWT from "jsonwebtoken";

// ══════════════════════════════════════════════════════════════════════════════
// MOCK DECLARATIONS
// ══════════════════════════════════════════════════════════════════════════════

jest.mock("../models/userModel.js");
jest.mock("../helpers/authHelper.js");
jest.mock("jsonwebtoken");

// ══════════════════════════════════════════════════════════════════════════════
// TEST SUITE: AuthController
// ══════════════════════════════════════════════════════════════════════════════

describe("AuthController", () => {
  describe("loginController", () => {
    /**
     * Decision Table — loginController auth flow:
     *         | Rule 1 | Rule 2 | Rule 3 | Rule 4 |
     * --------|--------|--------|--------|--------|
     * C1: input valid?    |   N    |   Y    |   Y    |   Y    |
     * C2: user found?     |   -    |   N    |   Y    |   Y    |
     * C3: password match? |   -    |   -    |   N    |   Y    |
     * --------|--------|--------|--------|--------|
     * A1: 404 invalid      |   X    |        |        |        |
     * A2: 404 not registered|       |   X    |        |        |
     * A3: 200 invalid pw   |        |        |   X    |        |
     * A4: 200 success+token|        |        |        |   X    |
     */

    let req, res, mockUser;

    // ────────────────────────────────────────────────────────────────────────────
    // SETUP & TEARDOWN
    // ────────────────────────────────────────────────────────────────────────────

    beforeEach(() => {
      // Initialize request object with empty body
      req = {
        body: {},
      };

      // Initialize response object with chainable methods
      res = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn().mockReturnThis(),
      };

      // Mock user object matching userModel schema
      mockUser = {
        _id: "507f1f77bcf86cd799439011",
        name: "Test User",
        email: "test@example.com",
        phone: "1234567890",
        address: { street: "123 Test St", city: "Test City" },
        role: 0,
        password: "$2b$10$hashedPasswordExample",
      };
    });

    afterEach(() => {
      // Clear all mocks to ensure test isolation
      jest.clearAllMocks();
    });

    // ══════════════════════════════════════════════════════════════════════════════
    // HAPPY PATH TESTS (EP: Valid Partition)
    // ══════════════════════════════════════════════════════════════════════════════

    describe("Happy Path", () => {
      const mockToken = "mock.jwt.token.xyz";

      beforeEach(() => {
        // EP: Valid partition — both email and password present
        req.body = {
          email: "test@example.com",
          password: "validPassword123",
        };
        userModel.findOne.mockResolvedValue(mockUser);
        comparePassword.mockResolvedValue(true);
        JWT.sign.mockResolvedValue(mockToken);
      });

      it("should return 200 with success message and token when credentials are valid", async () => {
        // ── ARRANGE ── (in beforeEach)

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(200);
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            success: true,
            message: "login successfully",
            token: mockToken,
          })
        );
      });

      it("should return correct user data shape when credentials are valid", async () => {
        // ── ARRANGE ── (in beforeEach)

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            user: {
              _id: mockUser._id,
              name: mockUser.name,
              email: mockUser.email,
              phone: mockUser.phone,
              address: mockUser.address,
              role: mockUser.role,
            },
          })
        );
      });
    });

    // ══════════════════════════════════════════════════════════════════════════════
    // INPUT VALIDATION (EP: Invalid Partition + BVA: Null/Empty Boundaries)
    // ══════════════════════════════════════════════════════════════════════════════

    describe("Boundary Values", () => {
      it("should return 404 with invalid credentials message when email is missing", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // EP: Invalid partition - missing required field (email)
        // BVA: Undefined value (field not present in object)
        req.body = {
          password: "somePassword",  // Only password provided, email undefined
        };

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid email or password",
        });
      });

      it("should return 404 with invalid credentials message when password is missing", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // EP: Invalid partition - missing required field (password)
        // BVA: Undefined value (field not present in object)
        req.body = {
          email: "test@example.com",  // Only email provided, password undefined
        };

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid email or password",
        });
      });

      it("should return 404 with invalid credentials message when both fields are missing", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // Decision Table: email=missing AND password=missing → validation error
        // EP: Invalid partition - both required fields missing
        req.body = {};  // Both fields undefined

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid email or password",
        });
      });

      it("should return 404 with invalid credentials message when email is empty string", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // BVA: On-boundary value - empty string (length = 0, just past valid minimum)
        // EP: Invalid partition - falsy email value
        req.body = {
          email: "",                  // BVA: Boundary - empty string
          password: "validPassword",
        };

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid email or password",
        });
      });

      it("should return 404 with invalid credentials message when email is null", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // BVA: Boundary value - null (distinct from undefined and empty string)
        // EP: Invalid partition - falsy email value
        req.body = {
          email: null,                // BVA: Explicit null value
          password: "validPassword",
        };

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid email or password",
        });
      });
    });

    // ══════════════════════════════════════════════════════════════════════════════
    // ERROR HANDLING
    // ══════════════════════════════════════════════════════════════════════════════

    describe("Error Handling", () => {
      it("should return 404 with email not registered message when user is not found", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // EP: Valid input format, but user doesn't exist (negative test case)
        // State Transition: Valid input → User lookup → Not found state
        req.body = {
          email: "nonexistent@example.com",
          password: "somePassword",
        };

        // STUB: Database returns null (user not found)
        userModel.findOne.mockResolvedValue(null);

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Email is not registered", // Note: typo exists in original code
        });
      });

      it("should return 200 with invalid password message when password does not match", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // EP: Valid email, invalid password (authentication failure partition)
        // State Transition: User found → Password comparison → Mismatch state
        req.body = {
          email: "test@example.com",
          password: "wrongPassword",
        };

        userModel.findOne.mockResolvedValue(mockUser);
        // STUB: comparePassword returns false (passwords don't match)
        comparePassword.mockResolvedValue(false);

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        // Note: Original code returns 200 for invalid password (security issue: should be 401)
        // Test validates actual behavior, not ideal behavior
        expect(res.status).toHaveBeenCalledWith(200);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Invalid Password",
        });
      });

      it("should return 500 with error message when findOne throws an error", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // Error Guessing: Database failure scenario (connection loss, timeout, etc.)
        req.body = {
          email: "test@example.com",
          password: "validPassword",
        };

        // STUB: Database query throws error (simulating connection failure)
        const dbError = new Error("Database connection failed");
        userModel.findOne.mockRejectedValue(dbError);

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Error in login",
          error: dbError,
        });
      });

      it("should return 500 with error message when comparePassword throws an error", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // Error Guessing: Bcrypt library failure (corrupted hash, memory error, etc.)
        req.body = {
          email: "test@example.com",
          password: "validPassword",
        };

        userModel.findOne.mockResolvedValue(mockUser);
        // STUB: bcrypt comparison throws error (simulating crypto failure)
        const bcryptError = new Error("Bcrypt comparison failed");
        comparePassword.mockRejectedValue(bcryptError);

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Error in login",
          error: bcryptError,
        });
      });

      it("should return 500 with error message when JWT sign throws an error", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // Error Guessing: JWT generation failure (invalid secret, library error, etc.)
        req.body = {
          email: "test@example.com",
          password: "validPassword",
        };

        userModel.findOne.mockResolvedValue(mockUser);
        comparePassword.mockResolvedValue(true);
        // STUB: JWT signing throws error (simulating token generation failure)
        const jwtError = new Error("JWT signing failed");
        JWT.sign.mockRejectedValue(jwtError);

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.send).toHaveBeenCalledWith({
          success: false,
          message: "Error in login",
          error: jwtError,
        });
      });
    });


    // ══════════════════════════════════════════════════════════════════════════════
    // SECURITY INVARIANTS
    // ══════════════════════════════════════════════════════════════════════════════

    describe("Security Invariants", () => {
      it("should exclude password from response when credentials are valid", async () => {
        // ── ARRANGE ──────────────────────────────────────────────────────────
        // Security Test: Verify sensitive data (password) is not leaked in response
        req.body = {
          email: "test@example.com",
          password: "validPassword123",
        };
        userModel.findOne.mockResolvedValue(mockUser);  // mockUser contains password field
        comparePassword.mockResolvedValue(true);
        JWT.sign.mockResolvedValue("mock.jwt.token");

        // ── ACT ──────────────────────────────────────────────────────────────
        await loginController(req, res);

        // ── ASSERT ───────────────────────────────────────────────────────────
        // Security Assertion: Password must not be included in response
        expect(res.send).toHaveBeenCalledWith(
          expect.objectContaining({
            user: expect.not.objectContaining({ password: expect.anything() }),
          })
        );
      });

    });
  });
});